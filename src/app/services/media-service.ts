import { EventEmitter, Injectable } from '@angular/core';
import { io, Socket } from 'socket.io-client';

@Injectable({
  providedIn: 'root',
})
export class MediaService {
  private socket:Socket;
  private peerConnection!:RTCPeerConnection;
  private localStream!: MediaStream;

  public incomingCall = new EventEmitter<void>();
  public callAccepted = new EventEmitter<MediaStream>();
  public remoteStream = new EventEmitter<MediaStream>();

  constructor(){
    this.socket=io('https://192.168.1.4:3000');
    this.initializeSocketEvents();
  }

  //Request acces to the local media devices (camera and microphone)
  async initializeMedia(){
    try{
      //Request access to video and audio (audio is set to false here)
      this.localStream=await navigator.mediaDevices.getUserMedia({video:true,audio:false});
      return this.localStream;
    }catch(error){
      console.error('Error accessing media devices',error);
      throw error;
    }
  }

  //Setup events listeners for socketio to handle signaling messages
  initializeSocketEvents(){

    //Listen for an offer message from the caller
    this.socket.on('offer',async(offer)=>{
      console.log("Received offer");
      this.incomingCall.emit();
      await this.createPeerConnection();
      await this.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    });

    //listen for an answer message from the callee
    this.socket.on('answer',(answer)=>{
      console.log("Received answer")
      this.peerConnection.setRemoteDescription(new RTCSessionDescription(answer))
    });

    //listen for ICE candidate messages
    this.socket.on('candidate',(candidate)=>{
      console.log("Received ICE candidate");
      this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    })

  }
  createPeerConnection() {

    //Initialize the peer connection with an optional STUN server for NAT gateway
    this.peerConnection = new RTCPeerConnection({
      iceServers:[{urls:'stun:stun.1.google.com:19302'}]
    });

    //Listen for ICE candidates generated by the peer connection and send them to the other peer
    this.peerConnection.onicecandidate=(event)=>{
      if (event.candidate) this.socket.emit('candidate',event.candidate);
    };

    //Listen for incoming media (video/audio) tracks from the remote peer
    this.peerConnection.ontrack=(event)=>{
      console.log("Setting remote stream");
      this.remoteStream.emit(event.streams[0]);
    }

  }

  //Starts a call by creating an offer and sending it to the callee
  async startCall(){
    await this.createPeerConnection();
    this.localStream.getTracks().forEach(track =>
      this.peerConnection.addTrack(track,this.localStream)
    );
    const offer = await this.peerConnection.createOffer();
    await this.peerConnection.setLocalDescription(offer);
    this.socket.emit('offer',this.peerConnection.localDescription);
  }

  async acceptCall(){
    this.localStream.getTracks().forEach(track=>
      this.peerConnection.addTrack(track,this.localStream)
    );
    const answer = await this.peerConnection.createAnswer();
    await this.peerConnection.setLocalDescription(answer);
    this.socket.emit('answer',this.peerConnection.localDescription);
  }

  rejectCall(){
    this.cleanup();
  }

  //Stops the call by stopping media tracks.
  stopCall(){
    this.cleanup();

    if(this.localStream){
      this.localStream.getTracks().forEach(
        track=>track.stop()
      );
    }

    this.remoteStream.emit(null as any);
  }

  cleanup(){
    if(this.peerConnection){
      this.peerConnection.close();
      this.peerConnection = null as any;
    }
  }
}
